js_strict(true);

include('config.dbl');
include('pause.dbl');
include('constants.dbl');

var _CommonGlobalLock = null;

addEventListener("scriptmsg", function(check, obj) {
	if(check == "lock")
	{
		_CommonGlobalLock = obj;
		removeEventListener("scriptmsg", arguments.callee);
	}
});
getScript(true).send(getScript(true), "get-lock");

const CLICK_DOWN	= 0x1;
const CLICK_UP		= 0x2;
const CLICK_HOLD	= 0x8;
const CLICK_SINGLE	= CLICK_DOWN|CLICK_UP;
const HAND_RIGHT	= 0x10;
const HAND_LEFT		= 0x20;

function display() {
	var msg = '';
	for(var i = 0; i < arguments.length; i++) msg += ' ' + arguments[i];
	var script = getScript(true).name.slice(0, -4);
	print(script+':'+msg);
}
function require(requirements, args) {
	for(var i = 0; i < requirements.length; i++)
	{
		let requirement = requirements[i];
		let argument = args[i];
		if(requirement.hasOwnProperty('valid') &&
		   isFunction(requirement.valid))
		{
			if(requirement.hasOwnProperty('optional') &&
			   requirement.optional &&
			   argument === undefined)
				continue;
			if(!requirement.valid(argument))
			{
				throw new Error("Argument " + i + (requirement.optional ? " (optional)" : "") +
					" of function " + require.caller.name +
					" violates the requirement " + requirement.valid.name + "!");
			}
		}
	}
}

function zip(a, b) {
	require([{valid: isArray}, {valid: isArray}], arguments);
	// [[x, y] for each(let x in a) for each(let y in b)]
	var result = [];
	for(var i = 0; i < a.length && i < b.length; i++)
		result.push([a[i], b[i]]);
	return result;
}

function moveDelay() { modeDelay([2, 3, 6]); }
function castDelay() { modeDelay([10]); }
function neutralDelay() {doDelay(function(){return me.mode!=1&&me.mode!=5;});}
function UIDelay(type) { doDelay(function(){return !getUIFlag(type);}); }
function modeDelay(modes) {
	require([{valid: isArray}], arguments);
	doDelay(function() {
		return modes.some(function(e) {
			return me.mode==e;
		});
	});
}
function doDelay(predicate, delay, maxlen) {
	delay = delay || 25;
	maxlen = maxlen || -1;
	require([{valid: isFunction}], arguments);
	var i = 0;
	do {
		if(maxlen > 0 && i*delay >= maxlen) return;
		i++;
		sleep(delay);
	} while(predicate(i) === true);
}

Unit.prototype.__defineGetter__("isInTown", function() {
	switch(this.area) {
		case 1: case 40: case 75: case 103: case 109: return true;
		default: return false;
	}
});

PresetUnit.prototype.__defineGetter__("realx", function() {
	return this.roomx * 5 + this.x;
});
PresetUnit.prototype.__defineGetter__("realy", function() {
	return this.roomy * 5 + this.y;
});

me.hasSkill = function (x) {
	return getSkillLevel(x, 0) > 0;
};
me.getSkillLvl = function (x) {
	if(isString(x))
		x = getSkillByName(x);
	return me.getSkill(x, 0);
};
me.useSkill = function(hand, shift, x, y, id) {
	if(!me.hasSkill(id)) throw new Error('Invalid skill');
	if(isString(id)) id = getSkillByName(id);

	var which = (hand == HAND_LEFT ? 1 : 0);
	if(me.getSkill(2+which) != id) me.setSkill(id, which);
	click(CLICK_SINGLE|hand, shift, x, y);
	castDelay();
};
me.__defineGetter__("isInTown", function() {
	switch(me.area) {
		case 1: case 40: case 75: case 103: case 109: return true;
		default: return false;
	}
});

function click(mode, shift) {
	var point = null;
	var hasUnit = isUnit(arguments[1]);
	if(arguments.length >= 2 && hasUnit)
		point = {x: arguments[1], y: arguments[2]};
	else if(arguments.length >= 3 && isNumber(arguments[1]) && isNumber(arguments[2]))
		point = unit;
	else
		throw new Error('Invalid click point');

	var down	= hasBit(mode, CLICK_DOWN),
		up		= hasBit(mode, CLICK_UP),
		held	= hasBit(mode, CLICK_HOLD),
		left	= hasBit(mode, HAND_LEFT),
		right	= hasBit(mode, HAND_RIGHT);
	if(left && right)
		throw new Error('Invalid hand selection');
	if(down && held && up)
		throw new Error('Invalid click selection');

	_CommonGlobalLock.lock();
	if(down)
	{
		var clickMode = (left ? 0 : (right ? 3 : -1));
		if(clickMode == -1)
			throw new Error('Invalid click mode');
		var args = [(clickMode + (held ? 1 : 0)), shift,
					(hasUnit ? point : point.x),
					(hasUnit ? undefined : point.y)];

		clickMap.apply(null, args);
		sleep(100);
	}
	if(up)
	{
		var clickMode = (left ? 2 : (right ? 5 : -1));
		if(clickMode == -1)
			throw new Error('Invalid click mode');
		var args = [clickMode, shift,
					(hasUnit ? point : point.x),
					(hasUnit ? undefined : point.y)];

		clickMap.apply(null, args);
		sleep(100);
	}
	_CommonGlobalLock.unlock();
}

Unit.prototype.moveTo = function(callback) {
	if(this.gid != me.gid)
		// only moveTo the object if it's not me!
		me.moveTo(this.x, this.y, callback, this.area);
};
PresetUnit.prototype.moveTo = function(callback) {
	me.moveTo(this.realx, this.realy, callback, this.level);
};
Room.prototype.moveTo = function(callback) {
	me.moveTo(this.x, this.y, callback, this.area);
};
Exit.prototype.moveTo = function(callback) {
	me.moveTo(this.x, this.y, callback, this.level);
};
Area.prototype.moveTo = function(callback) {
	me.moveTo(this.x, this.y, callback, this.id);
};

me.moveTo = function(x, y, callback, area) {
	callback = isFunction(callback) ? callback : function(){return true;};
	var path = generatePath(me.x, me.y, x, y, me.area, area);
	var point = false;
	while((point = path.next()) != false)
		moveTo(point);
	point.close();

	function moveTo(point) {
		require([{valid: function(x) { return isArray(x) || x.hasOwnProperty('UseWP'); }}], arguments);

		if(point.UseWP)
			throw new Error('Not implemented');
		var [x, y] = point,
			tele = me.hasSkill('teleport') && me.isInTown,
			dist = getDistance(me, x, y),
			movable = true, //(tele ? hasLoS(me, x, y) : isWalkable(me, x, y)),
			maxRange = (tele ? 30 : 15),
			moveFunc = (tele ? useSkill : click),
			delayFunc = (tele ? castDelay : moveDelay);

		do {
			if(dist > maxRange || !movable) {
				// generate a path and walk that instead
				throw new Error('Path not walkable!');
			}

			tele = me.hasSkill('teleport') && me.isInTown;
			dist = getDistance(me, x, y);
			movable = true; //(tele ? hasLoS(me, x, y) : isWalkable(me, x, y));
			maxRange = (tele ? 30 : 15);
			moveFunc = (tele ? function(h, x, y) { me.useSkill(h, x, y, getSkillById('teleport')); } : click);
			delayFunc = (tele ? castDelay : moveDelay);

			var args = [(tele ? HAND_RIGHT : CLICK_SINGLE|HAND_LEFT), false, x, y];
			moveFunc.apply(this, args);
			delayFunc();

			if(!callback(point))
				break;

		} while(dist > 4);
	}
};

function isUnit(obj) {
	return obj != null && obj != undefined &&
		typeof(obj) != 'undefined' && obj.hasOwnProperty('type') &&
		(obj.hasOwnProperty('gid') || obj.hasOwnProperty('id'));
}
function isNPC(obj) {
	return isUnit(obj) && obj.type == TYPE_UNIT &&
			obj.isInTown && obj.hasOwnProperty('name');
}
function isMonster(obj) {
	return isUnit(obj) && obj.type == TYPE_UNIT &&
			!obj.isInTown && obj.hasOwnProperty('name');
}
function isObject(obj) {
	return isUnit(obj) && obj.type == TYPE_OBJECT &&
			obj.hasOwnProperty('x') && obj.hasOwnProperty('y');
}
function isItem(obj) {
	return isUnit(obj) && obj.type == TYPE_ITEM &&
			obj.hasOwnProperty('location') &&
			obj.hasOwnProperty('name');
}
function isMissile(obj) {
	return isUnit(obj) && obj.type == TYPE_MISSILE;
}
function isPreset(obj) {
	return isUnit(obj) && obj.hasOwnProperty('roomx') && obj.hasOwnProperty('roomy');
}
function isArea(obj) {
	return typeof(obj) == 'object' &&
			obj.hasOwnProperty('id') &&
			obj.hasOwnProperty('name') &&
			obj.hasOwnProperty('exits');
}

function isNumber(obj) { return (typeof(obj) == 'number'); }
function isString(obj) { return (typeof(obj) == 'string'); }
function isBoolean(obj) { return (typeof(obj) == 'boolean'); }
function isError(obj) { return obj instanceof Error; }
function isArray(obj) {
	// arrays have a push and pop method, as well as a length and are a
	// typeof object
	// (undefined is also a typeof object... stupid ECMA spec!)
	return	typeof(obj) == 'object' && obj != undefined &&
			obj.hasOwnProperty('length') && isFunction(obj.push) &&
			isFunction(obj.pop);
}
function isFunction(obj) {
	return	typeof(obj) == 'function' &&
			typeof(obj.call) == 'function' &&
			typeof(obj.apply) == 'function';
}

function hasBit(num, bit) { return !!hasFlag((num >> bit), 0x1); }
function hasFlag(num, flag) { return !!((num & flag) == flag); }

function setBit(num, bit) { return setFlag(num, (1 << bit)); }
function setFlag(num, flag) { return (num | flag); }

function clearBit(num, bit) { return clearFlag(num, (1 << bit)); }
function clearFlag(num, flag) { return (num & flag); }

function sleep(milliseconds) {
	// ping/2 + (fps > 30 ? 0 : 30-fps)*10 + delay should be sufficient
	milliseconds = milliseconds > 0 ? milliseconds : 1;
	delay(milliseconds + (me.ping/2) + ((me.fps > 30 ? 0 : 30 - me.fps) *10));
}
